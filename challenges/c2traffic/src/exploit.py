from hashlib import sha256
import math
from Crypto.Cipher import AES
from Crypto.Util.number import *
import base64
from Crypto.Util.number import bytes_to_long, long_to_bytes
from Crypto.Random.random import randint
from Crypto.Util.Padding import pad, unpad
from sympy.ntheory import discrete_log

def long_to_base64(n):
    return base64.b64encode(long_to_bytes(n)).decode()

def encrypt(cipher, msg):
    return base64.b64encode(cipher.encrypt(pad(msg, 16))).decode()

def base64_to_long(e):
    return bytes_to_long(base64.b64decode(e))

def decrypt(cipher, e):
    return unpad(cipher.decrypt(base64.b64decode(e)), 16)

# baby_steps_giant_steps
def discrete_log(a,b,p,N = None):
    if not N: N = 1 + int(math.sqrt(p))

    #initialize baby_steps table
    baby_steps = {}
    baby_step = 1
    for r in range(N+1):
        baby_steps[baby_step] = r
        baby_step = baby_step * a % p

    #now take the giant steps
    giant_stride = pow(a,(p-2)*N,p)
    giant_step = b
    for q in range(N+1):
        if giant_step in baby_steps:
            return q*N + baby_steps[giant_step]
        else:
            giant_step = giant_step * giant_stride % p
    return "No Match"

A = base64_to_long("QpFOyA==")
p = base64_to_long("h3rl/Q==")
q = base64_to_long("Ag==")
B = base64_to_long("Ph6IeA==")
b = discrete_log(q, B, p)

shared = pow(A, b, p)
shared256 = sha256(long_to_bytes(shared)).digest()
cipher = AES.new(shared256, AES.MODE_ECB)
flag = decrypt(cipher, "3eWXhpQagWGMlfc71Qxd2QMvy4EVIyLfP54Jm6lpyHot6Qz+U7t3q2DdKnOxZBQf")
print(str(flag))