

# This file was *autogenerated* from the file exploit.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2212 = Integer(2212); _sage_const_1024 = Integer(1024); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_10 = Integer(10); _sage_const_8 = Integer(8); _sage_const_115792089210356248762697446949407573530086143415290314195533631308867097853951 = Integer(115792089210356248762697446949407573530086143415290314195533631308867097853951); _sage_const_0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b = Integer(0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b); _sage_const_3 = Integer(3); _sage_const_15957832354939571418537618117378383777560216674381177964707415375932803624163 = Integer(15957832354939571418537618117378383777560216674381177964707415375932803624163); _sage_const_66579344068745538488594410918533596972988648549966873409328261501470196728491 = Integer(66579344068745538488594410918533596972988648549966873409328261501470196728491); _sage_const_1337 = Integer(1337); _sage_const_2 = Integer(2); _sage_const_16 = Integer(16)
import socket
from Crypto.Cipher import AES
from Crypto.Hash import SHA256
from Crypto.Util.Padding import pad
from Crypto.Util.number import long_to_bytes

hostname = '46.101.107.117'
port = _sage_const_2212 

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((hostname, port))

# Get the inital leak
msg = s.recv(_sage_const_1024 )
r1 = int(msg.split(b"Your id is ")[_sage_const_1 ].split(b"\n")[_sage_const_0 ])

reference_stream = []
balance = _sage_const_10 

# Generate a random stream based on the PRNG numbers modulo 2
for _ in range(_sage_const_8 ):
    s.sendall(b'p\n')
    s.recv(_sage_const_1024 )
    s.sendall(b'1\n')

    response = s.recv(_sage_const_1024 )
    new_balance = int(response.split(b"balance: ")[_sage_const_1 ].split(b"\n")[_sage_const_0 ])

    if new_balance > balance:
       reference_stream.append(_sage_const_1 )
    else:
       reference_stream.append(_sage_const_0 )

    balance = new_balance

print(f"Reference stream: {reference_stream}")

# Copy & Paste from the challenge
class RNG:
    def __init__(self, state):
        p = _sage_const_115792089210356248762697446949407573530086143415290314195533631308867097853951 
        b = _sage_const_0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b 
        self.curve = EllipticCurve(GF(p), [-_sage_const_3 ,b])

        self.P = self.curve.lift_x(_sage_const_15957832354939571418537618117378383777560216674381177964707415375932803624163 )
        self.Q = self.curve.lift_x(_sage_const_66579344068745538488594410918533596972988648549966873409328261501470196728491 )
        
        self.state = state
        
    def next(self):
        r = (self.state * self.P)[_sage_const_0 ].lift()
        self.state = (r * self.P)[_sage_const_0 ].lift()
        return (r * self.Q)[_sage_const_0 ].lift() >> _sage_const_8 

p = _sage_const_115792089210356248762697446949407573530086143415290314195533631308867097853951 
b = _sage_const_0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b 

curve = EllipticCurve(GF(p), [-_sage_const_3 ,b])
P = curve.lift_x(_sage_const_15957832354939571418537618117378383777560216674381177964707415375932803624163 )
Q = curve.lift_x(_sage_const_66579344068745538488594410918533596972988648549966873409328261501470196728491 )

# This only needs to be done once, takes a few seconds
# d = Q.discrete_log(P)
d = _sage_const_1337 

# Get a stream based on a state
def get_stream(state):
    r = RNG(state)
    l = []
    
    for _ in range(_sage_const_8 ):
        l.append(r.next() % _sage_const_2 )
        
    return l

# Go through all possible states (256 possibilities)
r_x_guess = r1 << _sage_const_8 

for i in range(_sage_const_0 , _sage_const_2 **_sage_const_8 ):
    try:
        R = curve.lift_x(r_x_guess)
        state = Integer((d * R)[_sage_const_0 ])
        print(f"Possible state {state}")

        # If the two streams match we likely found the correct one
        if (get_stream(state) == reference_stream):
            print(f"found state {i}")

            rng = RNG(state)

            # Skip over the first 8 states since they have been used already
            for _ in range(_sage_const_8 ):
                rng.next()

            # Gamble enough to be able to buy the flag
            for _ in range(_sage_const_1337  + _sage_const_8 ):
                s.sendall(b'p\n')
                s.recv(_sage_const_1024 )

                if (rng.next() % _sage_const_2  == _sage_const_0 ):
                    s.sendall(b'0\n')
                else:
                    s.sendall(b'1\n')
            
                response = s.recv(_sage_const_1024 )
                new_balance = int(response.split(b"balance: ")[_sage_const_1 ].split(b"\n")[_sage_const_0 ])
                print(new_balance)

            # Buy the flag
            s.sendall(b'b\n')
            ct = int(s.recv(_sage_const_1024 ).split(b'\n')[_sage_const_0 ], _sage_const_16 )
            print(f"Bought the flag and got the ciphertext: {ct}")

            key = SHA256.new(str(rng.next()).encode('ascii')).digest()
            cipher = AES.new(key, AES.MODE_ECB)
            print(f"Flag: {cipher.decrypt(long_to_bytes(ct))}")
            exit()
    except:
        pass
    r_x_guess += _sage_const_1 

s.shutdown(socket.SHUT_WR)
s.close()


